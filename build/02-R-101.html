<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="generator" content="pandoc"><title>R 101</title><link href="css/bootstrap.min.css" rel="stylesheet"><link href="css/highlight.css" rel="stylesheet"><link href="css/courser.css" rel="stylesheet"><script src="js/modernizr-2.6.2.min.js"></script></head><body>

<!-- site-wide nav bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="container">
  
    <!-- bits that show in small windows -->
    <div class="navbar-header">
      <a href="http://rna.wlu.edu/bio285" class="navbar-brand">bio285</a>
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    
    <!-- bits that show in large windows -->
    <div class="navbar-collapse collapse" id="navbar-main">
    
      <!-- bits on the left -->
      <ul class="nav navbar-nav"><li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="Background">Background <span class="caret"></span></a>
          <ul class="dropdown-menu" aria-labelledby="Background"><li><a href="01-why-r.html">Why R?</a></li>
            <li><a href="02-R-101.html">R 101</a></li>
          </ul></li>
      </ul><!-- bits on the right --><ul class="nav navbar-nav navbar-right"><li><a href="02-R-101-slides.html" target="_blank">slides</a></li>
        
        <li><a href="http://rna.wlu.edu/r" target="_blank">RStudio</a></li>
      </ul></div>
    
  </div>
</div><div class="container">


<div class="page-header" id="banner">
<div class="row">

<div class="col-md-8">
<h1>R 101</h1>
<p>A practical introduction to working with data in R, including working with variables, functions and importing data. Everything you need to know how to do in R to avoid ever having to use Excel again!</p>
</div>

<div class="col-md-4" style="padding: 5px 5px 0 5px;">
<div class="well">  <!-- class="clearfix"? -->
<ul><li><a href="#working-with-simple-data">Working with simple data</a></li>
<li><a href="#indexing-syntax-in-r">Indexing syntax in R</a></li>
<li><a href="#bigger-data-structures">Bigger data structures</a></li>
<li><a href="#working-with-tables">Working with Tables</a></li>
<li><a href="#homework-excercise">Homework excercise</a></li>
</ul></div>
</div>

</div>
</div>

<div id="working-with-simple-data" class="section level1">
<h1>Working with simple data</h1>
<div id="interacting-with-r" class="section level2">
<h2>Interacting with R</h2>
<p>The command line is the primary mechanism that you’ll use to interact with R. When you enter instructions the R interpreter will perform computations for you.</p>
<p>While this may seem like an arcane method for interacting with software, it has one <em>huge</em> advantage over point-and-click environments: it is incredibly easy to repeat or abstract computations that you need to do often or on very large data sets. Any instruction that you type at the R command line can also be saved to a “R script” file. These files are just plain text files (by convention, R scripts have a “.r” or “.R” at the end of the file name). Running an R script is identical to hand typing all of the commands in that script at the command line.</p>
<p>Let’s try entering some simple math expressions to see how this interaction with the command line works. In the code examples you’ll see on this site the commands you type are followed by the text or visual output that R produces.</p>
<p>What do you think will happen when you enter these commands? Try it out.</p>
<pre class="r"><code>1 + 2
2 * 3
4 ^ 5
6.7 / 8.9</code></pre>
<p>As you might expect, R recognizes the standard syntax for numbers and mathematical operators. When you’ve enter a complete <a href="http://en.wikipedia.org/wiki/Expression_(computer_science)">expression</a> at the command line and hit “enter”, R <a href="http://en.wikipedia.org/wiki/Evaluation_strategy">evaluates</a> the result of that expression. If you don’t tell R what to do with the result, it will just print out a representation of the value on the next line.</p>
</div>
<div id="getting-help" class="section level2">
<h2>Getting help</h2>
<p>Manual pages for all of the functions in base R and R packages are built into the language. To quickly get help for any function you can use the <code>?</code> syntax.</p>
<p>To get the help page for the <code>c()</code>:</p>
<pre class="r"><code>## ?c
## help(c)</code></pre>
<p>If you are working in <a href="http://www.rstudio.com/">RStudio</a> you can search for help using the search box on the Help tab (lower right panel by default). You can also get help by putting your cursor over a function name in the editor or console and hitting F1.</p>
</div>
<div id="saving-data-in-variables" class="section level2">
<h2>Saving data in variables</h2>
<p>Often, though, you will want to perform a calculation and save the result for later use. If you’ve used Excel, you’ve probably used cells on a worksheet to hold the results of calculations based on the data in other cells. In R we can save the results of computations in <a href="http://en.wikipedia.org/wiki/Variable_(computer_science)">variables</a>. To do this we’ll use the assignment operator, which is a little arrow in R <code>&lt;-</code>.</p>
<p>If you’re coming from another programming language and the arrow syntax bugs you, you <em>can</em> use <code>=</code> operator for general assignment – see the R help pages for a few important edge cases.</p>
<pre class="r"><code>a &lt;- 10
a</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>b &lt;- a + 11
b</code></pre>
<pre><code>## [1] 21</code></pre>
<pre class="r"><code>c &lt;- a / b
c</code></pre>
<pre><code>## [1] 0.4762</code></pre>
</div>
<div id="section" class="section level2">
<h2></h2>
<p>If you’re working with very large numbers you can use for scientific notation:</p>
<p><code>r   2e10</code></p>
<p><code>## [1] 2e+10</code></p>
<p><code>r   2 * 10^10</code></p>
<p><code>## [1] 2e+10</code></p>
<p><code>r   2e10 == 2 * 10^10</code></p>
<p><code>## [1] TRUE</code></p>
<p>In that last line we used the comparison operator <code>==</code>; it tests whether or not two values are equivalent.</p>
<p>Finally, let’s see what happens if we try hitting <code>enter</code> before we’ve finished entering a complete expression. Type <code>2 +</code> and then hit <code>enter</code>. You’ll see a little <code>+</code> shows up as your prompt on the next line. This is R’s way of telling you the text you’ve entered so far isn’t a complete thought. Finish this expression by entering another number and hitting <code>enter</code> again.</p>
</div>
<div id="everything-is-a-vector" class="section level2">
<h2>Everything is a vector</h2>
<p>In the above expressions we appeared to be doing computations on single numbers. In fact, something more complicated was going on under the hood. In R all data are actually <a href="http://en.wikipedia.org/wiki/Array_data_structure">vectors</a> of data.</p>
<p>Unlike other programming languages, there are no atomic values in R; the most basic data structure is a vector. Single values are just vectors with one element. This may seem odd at first, until you consider the key implication: all operators and functions in R are built to handle vectors of data, not just single values. This means anything that can be done with a single number can also be done with a vector of numbers. This is a language that was clearly designed by statisticians!</p>
<p>You can see how many elements a vector holds using the <code>length</code> function:</p>
<p><code>r   length(10)</code></p>
<p><code>## [1] 1</code></p>
<p><code>r   length(c)</code></p>
<p><code>## [1] 1</code></p>
<p><code>r   length(1:10)</code></p>
<p><code>## [1] 10</code></p>
<p>Above, <code>length</code> is the first example we’ve seen of an R <a href="http://en.wikipedia.org/wiki/Function_(programming)">function</a>. In programming, functions are analogous to their mathematical counter parts: they take in one or more values and evaluate to a new value. The R syntax for running, or “calling”, a function is in the form of <code>functionName(value1, value2, ...)</code>.</p>
</div>
<div id="composing-vectors" class="section level2">
<h2>Composing vectors</h2>
<p>The <code>length</code> function has reported that we’ve been working with vectors of 1 element so far. To <strong>c</strong>ompose a vector with more than one element, we’ll use the <code>c()</code> function:</p>
<pre class="r"><code>c(1,2,3,4)</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<pre class="r"><code>d &lt;- c(5,6,7,8)
d + 10</code></pre>
<pre><code>## [1] 15 16 17 18</code></pre>
<pre class="r"><code>d + d</code></pre>
<pre><code>## [1] 10 12 14 16</code></pre>
<p>As you can see, mathematical operators in R are built to handle vectorized operations: we could add a 4 element vector <code>d</code> to a one element vector <code>10</code> and get a sensible result.</p>
<p><strong>Side note for programmers</strong>: if you’re coming to R with a background in other programming languages, you might have caught something in the last code block that freaked you out. We had previously assigned the variable <code>c</code> to hold a number; yet we were still able to call the built-in <code>c</code> function from this scope. In almost any other common scripting language this would not have worked. Although base scoping rules in R are strictly lexical, there are a number of aggressive additional checks that are performed on lookup or evalution failures. For example, when an attempt is made to apply a non-function in an inner scope, the interpreter will ascend the scope chain looking for upvalues that <em>are</em> functions. This is why we were able to bind <code>c</code> to a vector of numbers in our current scope and also apply the base R <code>c()</code> function. Another example of this design philosophy at play in R is aggressive partial matching for named arguments in function calls.</p>
</div>
<div id="strings" class="section level2">
<h2>Strings</h2>
<p>So far we’ve just been working with numbers (<code>numeric</code> values in R lingo), but R also supports text (<code>string</code> values) and true/false (<code>boolean</code> values) data.</p>
<p>To create strings, surround your text with either double <code>" ... "</code> or single <code>' ... '</code> quotes:</p>
<pre class="r"><code>"a"</code></pre>
<pre><code>## [1] "a"</code></pre>
<pre class="r"><code>"a" == 'a'</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>c( "a", "b", "c", "d" )</code></pre>
<pre><code>## [1] "a" "b" "c" "d"</code></pre>
</div>
<div id="escape-characters" class="section level2">
<h2>Escape characters</h2>
<p>You can create strings containing single quotes using double quotes and visa versa, but if you need to make a string that contains both single and double quotes you need to use the <code>\</code> “escape” character:</p>
<pre class="r"><code>s &lt;- "My data are \"awesome\"!"
cat(s)</code></pre>
<pre><code>## My data are "awesome"!</code></pre>
</div>
<div id="section-1" class="section level2">
<h2></h2>
<p>Two other special string characters are tab <code>\t</code> and newline <code>\n</code>:</p>
<pre class="r"><code>s &lt;- "a\tb\tc"
cat(s)</code></pre>
<pre><code>## a    b   c</code></pre>
<pre class="r"><code>s &lt;- "a\nb\nc"
cat(s)</code></pre>
<pre><code>## a
## b
## c</code></pre>
</div>
<div id="boolean-values" class="section level2">
<h2>Boolean values</h2>
<p>To create boolean values use <code>TRUE</code> or <code>FALSE</code>:</p>
<pre class="r"><code>TRUE</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>FALSE</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>TRUE == FALSE</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
<div id="missing-data" class="section level2">
<h2>Missing Data</h2>
<p>R has built-in support for flagging values as missing data. The special <code>NA</code> value can be mixed with any other kind of data in a vector. For example:</p>
<pre class="r"><code>c(1, 2, NA, 4)</code></pre>
<pre><code>## [1]  1  2 NA  4</code></pre>
<pre class="r"><code>c( "a", NA, "c", NA )</code></pre>
<pre><code>## [1] "a" NA  "c" NA</code></pre>
<pre class="r"><code>c(TRUE, FALSE, NA, FALSE)</code></pre>
<pre><code>## [1]  TRUE FALSE    NA FALSE</code></pre>
<pre class="r"><code>is.na( c(1, NA) )</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p>Most R functions will either understand how to deal with missing data, or issue an error if they involve a type of statistical analysis that can’t be used with missing data.</p>
</div>
<div id="a-note-about-null" class="section level2">
<h2>A note about NULL</h2>
<p>R also has a special “no-value” type called <code>NULL</code>. If you are coming to R from another programming language it is easy confuse <code>NA</code> and <code>NULL</code> (for example, in Python data analysis modules the <code>None</code> type is often used to do double duty, signifying <code>NULL</code> or <code>NA</code> depending on the context). By convention, you should use <code>NA</code> in data structures to represent missing data points.</p>
<p><code>NULL</code> is used to signify unassigned variables:</p>
<p><code>r   NULL   is.null(NULL)</code></p>
<p><code>## [1] TRUE</code></p>
</div>
</div>
<div id="indexing-syntax-in-r" class="section level1">
<h1>Indexing syntax in R</h1>
<div id="extracting-values" class="section level2">
<h2>Extracting values</h2>
<p>Let’s say we have a vector of numbers:</p>
<pre class="r"><code>myNumbers &lt;- c( 10, 20, 30, 40, 50 )</code></pre>
</div>
<div id="section-2" class="section level2">
<h2></h2>
<p>We can extract elements from 1D vectors using the index syntax <code>[]</code> and integers:</p>
<pre class="r"><code>myNumbers</code></pre>
<pre><code>## [1] 10 20 30 40 50</code></pre>
<pre class="r"><code>myNumbers[1]</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>myNumbers[3]</code></pre>
<pre><code>## [1] 30</code></pre>
</div>
<div id="section-3" class="section level2">
<h2></h2>
<p>Here, we’ve extracted elements at the position given by the integer we put inside of the <code>[...]</code>. Remember that the numbers <code>1</code> and <code>3</code> in the code above are actually <em>vectors</em> of integers.</p>
<p>We can use integer vectors with more than one element inside of our index <code>[...]</code>’s::</p>
<pre class="r"><code>myNumbers[ c(1, 3) ]</code></pre>
<pre><code>## [1] 10 30</code></pre>
</div>
<div id="section-4" class="section level2">
<h2></h2>
<p>You can use the <code>:</code> operator to easily create a sequence of numbers:</p>
<pre class="r"><code>2:4</code></pre>
<pre><code>## [1] 2 3 4</code></pre>
<pre class="r"><code>myNumbers[2:4]</code></pre>
<pre><code>## [1] 20 30 40</code></pre>
</div>
<div id="section-5" class="section level2">
<h2></h2>
<p>In addition to putting integer vectors inside of the index <code>[...]</code> we can also use logical vectors. If we do, <code>TRUE</code> at a position causes a value to be extracted, while a <code>FALSE</code> indicates that it should be skipped. Let’s look at an example:</p>
<p><code>r   myNumbers</code></p>
<p><code>## [1] 10 20 30 40 50</code></p>
<p><code>r   myNumbers[ c(FALSE, TRUE , TRUE , TRUE , TRUE ) ]</code></p>
<p><code>## [1] 20 30 40 50</code></p>
<p><code>r   myNumbers[ c(TRUE , FALSE, FALSE, FALSE, FALSE) ]</code></p>
<p><code>## [1] 10</code></p>
</div>
<div id="section-6" class="section level2">
<h2></h2>
<p>So why would you ever want to do this? The answer lies in the combination of indexing and the logical operators (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, and <code>%in%</code>).</p>
<p>Logical operators always return a logical vector:</p>
<p><code>r   myNumbers &gt; 25</code></p>
<p><code>## [1] FALSE FALSE  TRUE  TRUE  TRUE</code></p>
<p><code>r   myNumbers &lt; 25</code></p>
<p><code>## [1]  TRUE  TRUE FALSE FALSE FALSE</code></p>
<p><code>r   myNumbers == 30</code></p>
<p><code>## [1] FALSE FALSE  TRUE FALSE FALSE</code></p>
<p><code>r   myNumbers != 30</code></p>
<p><code>## [1]  TRUE  TRUE FALSE  TRUE  TRUE</code></p>
</div>
<div id="section-7" class="section level2">
<h2></h2>
<p>The %in% asks if the first set of numbers can be found in the second:</p>
<p><code>r   30 %in% myNumbers</code></p>
<p><code>## [1] TRUE</code></p>
<p><code>r   c(10, 100) %in% myNumbers</code></p>
<p><code>## [1]  TRUE FALSE</code></p>
</div>
<div id="section-8" class="section level2">
<h2></h2>
<p>The ! operator negates (flips) each value of a logical vector:</p>
<p><code>r   !TRUE</code></p>
<p><code>## [1] FALSE</code></p>
<p><code>r   !(myNumbers &gt; 25)</code></p>
<p><code>## [1]  TRUE  TRUE FALSE FALSE FALSE</code></p>
<p><strong>A note about <code>=</code> vs <code>==</code>:</strong> Many beginers are confused by the difference between <code>=</code> and <code>==</code>. The <code>=</code> operator is used for value assignment, traditionally for arguments inside of function calls such as <code>plot(x = 10, y = 1)</code>, or in newer versions of R in place of the <code>&lt;-</code> operator as in <code>a = 10</code>. If you want to compare <em>equivalence</em> between two values you’ll want to use the double <code>==</code> operator. These operations will evaluate to a logical vector (<code>TRUE</code> or <code>FALSE</code>).</p>
</div>
<div id="section-9" class="section level2">
<h2></h2>
<p>So how can we combine logical comparisons with indexing?</p>
<pre class="r"><code>myNumbers[myNumbers &gt; 25]</code></pre>
<pre><code>## [1] 30 40 50</code></pre>
<pre class="r"><code>myNumbers[myNumbers &lt; 25]</code></pre>
<pre><code>## [1] 10 20</code></pre>
</div>
<div id="section-10" class="section level2">
<h2></h2>
<p>You can get fancy…</p>
<pre class="r"><code>myNumbers[ (myNumbers %% 2) == 0 ]</code></pre>
<pre><code>## [1] 10 20 30 40 50</code></pre>
<p>What happened there? If you need help figuring it out, look up the <code>%%</code> (<em>modulo</em>) operator on the help panel.</p>
</div>
<div id="assigning-values" class="section level2">
<h2>Assigning values</h2>
<p>Finally, the indexing <code>[...]</code> syntax isn’t just used to extract values from data structures. It can also be used to assign values <em>into</em> existing structures. For example:</p>
<p><code>r   myNumbers</code></p>
<p><code>## [1] 10 20 30 40 50</code></p>
<p><code>r   myNumbers[3]    &lt;- 100   myNumbers</code></p>
<p><code>## [1]  10  20 100  40  50</code></p>
<p><code>r   myNumbers[2:3]  &lt;- c(1,2)   myNumbers</code></p>
<p><code>## [1] 10  1  2 40 50</code></p>
</div>
</div>
<div id="bigger-data-structures" class="section level1">
<h1>Bigger data structures</h1>
<p>As we saw in the previous section, vectors are the basic building blocks of all data in R and can hold numeric, string or boolean values. Vectors can in turn be composed into more complicated data structures including matrixes, arrays, data frame’s and lists.</p>
<div id="matrix" class="section level2">
<h2>Matrix</h2>
<p>A matrix is a vector of vectors, each the same length and with the same type of data:</p>
<pre class="r"><code>m &lt;- matrix(1:8, nrow = 2, ncol = 4)
m</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    3    5    7
## [2,]    2    4    6    8</code></pre>
</div>
<div id="section-11" class="section level2">
<h2></h2>
<p>You access values on a matrix by using a one element index, refering to a n’th position:</p>
<p><code>r   m[2]</code></p>
<p><code>## [1] 2</code></p>
<p>Alternatively you can specify a <code>[row, col]</code>:</p>
<p><code>r   m[1,2]</code></p>
<p><code>## [1] 3</code></p>
</div>
<div id="section-12" class="section level2">
<h2></h2>
<p>Or just a row:</p>
<p><code>r   m[1,]</code></p>
<p><code>## [1] 1 3 5 7</code></p>
<p>Or just a column:</p>
<p><code>r   m[,2]</code></p>
<p><code>## [1] 3 4</code></p>
<p>If you forget this syntax, just pay attention to how R prints out matrixes!</p>
<p>## Array</p>
<p>An array is a matrix of more than two dimensions.</p>
<pre class="r"><code>array(1:8, dim=c(2,2,2))</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8</code></pre>
</div>
<div id="lists" class="section level2">
<h2>Lists</h2>
<p>Unlike arrays and matrixes, lists are collections of vectors where the individual vectors can hold different types of data:</p>
<p><code>r   l &lt;- list( a = c(1, 2, 3, 4)            , b = c("a", "b", "c")   )   l</code></p>
<p><code>## $a   ## [1] 1 2 3 4   ##    ## $b   ## [1] "a" "b" "c"</code></p>
</div>
<div id="section-13" class="section level2">
<h2></h2>
<p>You can access individual vectors on lists using indexing with numbers or names:</p>
<p><code>r   l[1]</code></p>
<p><code>## $a   ## [1] 1 2 3 4</code></p>
<p><code>r   l["a"]</code></p>
<p><code>## $a   ## [1] 1 2 3 4</code></p>
<p>Did you notice what type of thing was returned there?</p>
</div>
<div id="section-14" class="section level2">
<h2></h2>
<p>To simplify the result of indexing down to a vector (rather than a one element list):</p>
<p><code>r   l[[1]]</code></p>
<p><code>## [1] 1 2 3 4</code></p>
<p>The <code>$</code> is short hand for referencing a named element on a list:</p>
<p><code>r   l$a</code></p>
<p><code>## [1] 1 2 3 4</code></p>
</div>
</div>
<div id="working-with-tables" class="section level1">
<h1>Working with Tables</h1>
<p>R has great built-in support for working with data in tabular format. Tables in R are called “data frames.” By convention, response and annotation variables are arranged across the columns and observations down the rows. Columns, and optionally rows, can also be given unique names.</p>
<p>Under the hood, data.frame structures are just a specialized kind of a list – where each component vector (column) is of the same length.</p>
<div id="a-note-about-table-structure" class="section level2">
<h2>A note about table structure</h2>
<p>Before we dive into loading and working with tabular data in R, it’s worth taking a moment to consider a key difference between data formatting expectations in advanced statistical software packages like R and the bad habits most folks develop after years of working in Excel. If you’re used to working in other stats packages like SAS, SPSS or Minitab, you can skip this section.</p>
<p>Let’s consider a simple example experimental design: a response variable measured in two different treatment groups (A, B) over a 4 day period.</p>
<p>Excel has probably trained you to format data something like this:</p>
<table><thead><tr class="header"><th align="left">Day</th>
<th align="left">Group A</th>
<th align="left">Group B</th>
</tr></thead><tbody><tr class="odd"><td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr><tr class="even"><td align="left">2</td>
<td align="left">6</td>
<td align="left">7</td>
</tr><tr class="odd"><td align="left">3</td>
<td align="left">7</td>
<td align="left">9</td>
</tr><tr class="even"><td align="left">4</td>
<td align="left">8</td>
<td align="left">11</td>
</tr></tbody></table><p>The reason we have all learned to format the data this way in Excel is that it makes it easy to produce plots – if we select these cells and click the scatter plot wizard, we’ll get the desired plot with Day on the X-axis and two sets of points, one for Group A and the other Group B.</p>
<p>Statisticians, and by proxy statistical software packages, object to this formatting for an important reason. The problem is that we’ve mixed our concerns in designing the structure of these columns: (1) <em>two</em> different columns contain values for the <em>same</em> response being measured; (2) a second variable in this design (treatment) has to be inferred from the column headings.</p>
</div>
<div id="section-15" class="section level2">
<h2></h2>
<p>The correct design would be a three column table:</p>
<table><thead><tr class="header"><th align="left">Day</th>
<th align="left">Group</th>
<th align="left">Response</th>
</tr></thead><tbody><tr class="odd"><td align="left">1</td>
<td align="left">A</td>
<td align="left">5</td>
</tr><tr class="even"><td align="left">1</td>
<td align="left">B</td>
<td align="left">5</td>
</tr><tr class="odd"><td align="left">2</td>
<td align="left">A</td>
<td align="left">6</td>
</tr><tr class="even"><td align="left">2</td>
<td align="left">B</td>
<td align="left">7</td>
</tr><tr class="odd"><td align="left">3</td>
<td align="left">A</td>
<td align="left">7</td>
</tr><tr class="even"><td align="left">3</td>
<td align="left">B</td>
<td align="left">9</td>
</tr><tr class="odd"><td align="left">4</td>
<td align="left">A</td>
<td align="left">8</td>
</tr><tr class="even"><td align="left">4</td>
<td align="left">B</td>
<td align="left">11</td>
</tr></tbody></table><p>If you have a lot of data formatted in the first of these two formats, don’t worry. Restructuring your tables is easy to do in R, as is generating any new categorical label columns you might need. We can explore this topic in more detail if there’s interest, but as a preview the tools you’ll probably need are the <code>c(..., recursive = TRUE)</code> and <code>rep()</code> functions.</p>
</div>
<div id="loading-tabular-data" class="section level2">
<h2>Loading tabular data</h2>
<p>R can import tabular data from a wide variety of source file formats. Base R has excellent support for loading data using the <code>read.table</code> family of functions. There are also a wide array of R packages that support loading data from databases and other binary file formats. If you just need to move data from an Excel worksheet into R, the easiest path is to save it as a text file (tab-delimited or csv) and load it into R using <code>read.table</code>.</p>
<p>If you’re working in <a href="http://www.rstudio.com/">RStudio</a>, you can use the “Import Dataset” button on the Workspace tab to load data from a local file or over the web. Under-the-hood RStudio is just calling <code>read.table</code> for you, which we’ll explore below (see the History tab see the command that RStudio generated for you).</p>
<p>To follow along with this example, you can download the genetic code table and save it in your current working directory: <a href="&lt;a%20href=" data>data/codons.txt</a>"&gt;codons.txt. This table has two columns: “codon” and “aminoAcid.” To load the table into a variable:</p>
<p><code>r   codons &lt;- read.table( "<a href="data/codons.txt">data/codons.txt</a>"                       , header = TRUE                       , stringsAsFactors = FALSE   )   head(codons)</code></p>
<p><code>##   codon aminoAcid   ## 1   GCU         A   ## 2   GCC         A   ## 3   GCA         A   ## 4   GCG         A   ## 5   CGU         R   ## 6   CGC         R</code></p>
<p>The <code>read.table</code> function takes a large number of optional arguments which allows it to adapt to a wide variety of different file formats. Here we’ve specified <code>header = TRUE</code> because the first line of our file contains column headings. The <code>stringsAsFactors = FALSE</code> argument tells R not to try to convert text columns to a special type of data structure called a <code>factor</code>. Factors are intended to flag strings as describing levels of a categorical variable. They are a more advanced topic then we’ll dive into here; so we’ll turn them off.</p>
</div>
<div id="accessing-data-in-a-data.frame" class="section level2">
<h2>Accessing data in a data.frame</h2>
<p>Once your data is loaded into a data.frame (table), you can access vectors of data for individual variables in the table using the <code>$</code> syntax:</p>
<pre class="r"><code>codons$codon</code></pre>
<pre><code>##  [1] "GCU" "GCC" "GCA" "GCG" "CGU" "CGC" "CGA" "CGG" "AGA" "AGG" "AAU"
## [12] "AAC" "GAU" "GAC" "UGU" "UGC" "CAA" "CAG" "GAA" "GAG" "GGU" "GGC"
## [23] "GGA" "GGG" "CAU" "CAC" "AUU" "AUC" "AUA" "AUG" "UUA" "UUG" "CUU"
## [34] "CUC" "CUA" "CUG" "AAA" "AAG" "UUU" "UUC" "CCU" "CCC" "CCA" "CCG"
## [45] "UCU" "UCC" "UCA" "UCG" "AGU" "AGC" "ACU" "ACC" "ACA" "ACG" "UGG"
## [56] "UAU" "UAC" "GUU" "GUC" "GUA" "GUG" "UAA" "UGA" "UAG"</code></pre>
<pre class="r"><code>codons$aminoAcid</code></pre>
<pre><code>##  [1] "A"    "A"    "A"    "A"    "R"    "R"    "R"    "R"    "R"    "R"   
## [11] "N"    "N"    "D"    "D"    "C"    "C"    "Q"    "Q"    "E"    "E"   
## [21] "G"    "G"    "G"    "G"    "H"    "H"    "I"    "I"    "I"    "M"   
## [31] "L"    "L"    "L"    "L"    "L"    "L"    "K"    "K"    "F"    "F"   
## [41] "P"    "P"    "P"    "P"    "S"    "S"    "S"    "S"    "S"    "S"   
## [51] "T"    "T"    "T"    "T"    "W"    "Y"    "Y"    "V"    "V"    "V"   
## [61] "V"    "STOP" "STOP" "STOP"</code></pre>
<p>If we want to access a single data point we can use indexing syntax with <code>[]</code>. When we are working with a 2D data structure, we can specific a <code>[row, col]</code>:</p>
<pre class="r"><code>codons[ 1, 2 ]</code></pre>
<pre><code>## [1] "A"</code></pre>
<pre class="r"><code>codons[ 2, 1 ]</code></pre>
<pre><code>## [1] "GCC"</code></pre>
</div>
<div id="calculating-a-new-column" class="section level2">
<h2>Calculating a new column</h2>
<p>We can use the <code>$</code> syntax (like the <code>[...]</code>) to assign data to existing columns on a <code>data.frame</code> or to create a new column. Let’s say that we want to add a new column to our <code>codons</code> table that will annotate what type of amino acid is encoded by each codon (non-polar, polar, acidic or basic).</p>
<p>We can start by creating a new column called <code>type</code> that contains all <code>NA</code> values:</p>
<p><code>r   codons$type &lt;- NA   head(codons)</code></p>
<p><code>##   codon aminoAcid type   ## 1   GCU         A   NA   ## 2   GCC         A   NA   ## 3   GCA         A   NA   ## 4   GCG         A   NA   ## 5   CGU         R   NA   ## 6   CGC         R   NA</code></p>
</div>
<div id="section-16" class="section level2">
<h2></h2>
<p>Here could have hand-encoded a vector of 20 strings describing the type of each amino acid in our table. But we’ll take the lazier path and learn a few new R tricks along the way. Let’s make some vectors that describe which amino acids belong to each of the four categories:</p>
<p>```r # Assuming physiological pH; we’ll call histidine basic for simplicity! nonpolar &lt;- c( “A”, “C”, “G”, “I”, “L”, “M”, “F”, “P”, “W”, “V” ) polar &lt;- c( “N”, “Q”, “S”, “T”, “Y” ) acidic &lt;- c( “D”, “E” ) basic &lt;- c( “R”, “H”, “K” )</p>
<p># We can make sure we’ve annotated all 20 amino acids length( c( nonpolar, polar, acidic, basic ) ) == 20 ```</p>
<p><code>## [1] TRUE</code></p>
</div>
<div id="section-17" class="section level2">
<h2></h2>
<p>Now we can update our <code>type</code> column using the annotations that we’ve saved in these variables. The logical <code>%in%</code> operator tests whether or not one vector of values (left side) is found in another (right side). It returns a vector of boolean values of the same length as the left-hand test vector. So we can do this:</p>
<p>Which rows contain nonpolar amino acids?</p>
<pre class="r"><code>codons$aminoAcid %in% nonpolar</code></pre>
<pre><code>##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE
## [23]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [34]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
## [56] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE</code></pre>
</div>
<div id="section-18" class="section level2">
<h2></h2>
<p>We can use these logical vectors to assign our type annotations:</p>
<pre class="r"><code>codons[ codons$aminoAcid %in% nonpolar, "type" ] &lt;- "nonpolar"
codons[ codons$aminoAcid %in% polar,    "type" ] &lt;- "polar"
codons[ codons$aminoAcid %in% acidic,   "type" ] &lt;- "acidic"
codons[ codons$aminoAcid %in% basic,    "type" ] &lt;- "basic"</code></pre>
<p>Check to see if it worked!</p>
<p>Pretty neat, eh? Working with numeric data in table columns is even more straight forward. In R, it’s very easy to create new columns that are calculated from exisiting data, as you might be used to doing in Excel. In R, however, adding complex annotation columns like <code>type</code> above is also very simple.</p>
<p>Notice how we accomplished this task by composing a few minimal data structures, followed by a few relatively straight-forward assignments. We never had to repeat assignment of any of our amino acid types. In both software design and data analysis we always try to adhere to the “[DRY](<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">http://en.wikipedia.org/wiki/Don't_repeat_yourself</a>)” (don’t repeat yourself) principle.</p>
<p>This is much easier to do when working with tabular data in R than it is in traditional spreadsheet packages or other statistical environments.</p>
</div>
</div>
<div id="homework-excercise" class="section level1">
<h1>Homework excercise</h1>
<div id="implement-transcription-and-translation" class="section level2">
<h2>Implement transcription and translation</h2>
<p>The challenge – design an R script with a set of functions that will:</p>
<ul><li>Read the DNA sequence in the file “<a href="http://rna.wlu.edu/bio285/data/npl3-dna.txt">data/npl3-dna.txt</a>”</li>
<li>Transcribe it into RNA sequence</li>
<li>Save the results to a new file, rna.txt</li>
</ul><p>And the special challenge:</p>
<ul><li>Translate the DNA sequence to protein (using the “<a href="data/codons.txt">data/codons.txt</a>”)</li>
</ul></div>
<div id="parts-list" class="section level2">
<h2>Parts list:</h2>
<ul><li><code>readLines()</code> <em>hint</em> con = “dna.txt”</li>
<li><code>gsub()</code> <em>hint</em> fixed = true</li>
<li><code>write()</code></li>
</ul><div class="references">

</div>
</div>
</div>


</div>

<!-- bootstrap footer -->
<br><div class="container">
  <footer><div class="row">
      <div class="col-lg-12">
        <p>Original work copyright © 2014 <a href="http://www.wlu.edu/x23921.xml?InsertFile=x55999">Gregg Whitworth</a> and licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.  This page was built with <a href="https://github.com/whitwort/courseR">courseR</a>.</p>
      </div>
    </div>
  </footer></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="js/bootstrap.min.js"></script><script src="js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
</script></body></html>

