<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Lab:  Explorying Genomes</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Lab:  Explorying Genomes</h1>

<p>In lab today we are going to perform a <em>de novo</em> annotation of the entire yeast genome.  We&#39;ll be using R to find Open Reading Frames (ORFs) on yeast chromosomes, search for introns, and even annotate the locations of common transcription factor binding sites.  Because of the amazing power of R and modern computational hardware you&#39;ll be able to run your software to analyze the yeast genome in its entirety!</p>

<p>Here&#39;s an overview of each of the stages of today&#39;s lab:</p>

<ul>
<li><p>Step 1: refine <code>transcribe</code> and <code>translate</code>.  We&#39;ll start by refining your earlier versions of the <code>transribe</code> and <code>translate</code> functions.  We&#39;re going to use these to help us write an ORF finder.</p></li>
<li><p>Step 2: write an <code>findORF</code> function.  Next, we&#39;ll write a function which takes a string of amino acids and returns all of the possible true ORFs in that string.  This function will accept a <code>cutoff</code> argument which filters out ORFs which are likely too small to be real.</p></li>
<li><p>Step 3: write an <code>annotateChromosome</code> function which takes the name of a file containing genomic DNA sequence for a yeast chromosome and returns a <code>data.frame</code> where each row is a description of a different putative ORF on that chromosome.</p></li>
<li><p>Step 4: glue everything together with an <code>annotateGenome</code> function that loads DNA sequence for each yeast chromosome and annotates it with <code>annotateChromosome</code>.</p></li>
</ul>

<h1>Step 1: transcribe and translate</h1>

<h2>Refine your transcribe function</h2>

<p>In this lab we&#39;ll be using the two pieces of software you&#39;ve already written this week.  Let&#39;s start off by creating a fresh script file.  Use &ldquo;File&rdquo; &gt; &ldquo;New&rdquo; &gt; &ldquo;R Script&rdquo; in the Rstudio menus to open a blank script file.  Save this file with the name <code>genomeAnnotation.r</code>.</p>

<p>Now copy and paste one of the <code>transcribe</code> functions you wrote earlier in the week.  We&#39;re going to update the function <em>interface</em> to better meet our needs today.  When we talk about a function&#39;s interface, we mean (a) what the function expects you to pass into it as arguments, and (b) what the result of the function is, or it&#39;s value.  Today we&#39;re going to practice the good habit of using comment lines to keep a clear record of the interface for each of our functions, so that we don&#39;t get confused.</p>

<p>Here&#39;s a template for today&#39;s version of your transcribe function should look like:</p>

<pre><code class="r"># Transcibes DNA sequence into RNA equivalent
# 
# dna A character string containing DNA sequence
# 
# value A character string containing RNA sequence
transcribe &lt;- function(dna) {

    # Insert your code here

}
</code></pre>

<p>See how we&#39;ve used the comment lines to clearly describe:</p>

<ul>
<li>What our function does (fist line)</li>
<li>What kinds of data we expect for the arguments (dna)</li>
<li>What kinds of data the function produces (value)</li>
</ul>

<p>We&#39;ll write descriptions like this for all of the functions we include in our <code>genomeAnnotation.r</code> script today.</p>

<p>How is the interface for this transcribe function different from the version you wrote earlier in the week?  Update the body of your function so that it conforms to this new interface.  </p>

<p>Once you&#39;re finished load your script into the interactive session (console) so that you can test it.  You can load or <code>source</code> your script easily in couple of ways:</p>

<ul>
<li>Click on the <code>source</code> button on the right hand side of the script editor window</li>
<li>Hit <code>ctrl + shift + s</code></li>
<li>Check the &ldquo;Source on save&rdquo; check box and then save you changes to the script by click on the save button (disk icon) or hitting <code>ctrl + s</code></li>
</ul>

<p>Now let&#39;s test your transcribe function with some sample input:</p>

<pre><code class="r">transcribe(&quot;ATGCTTATCTA&quot;)
</code></pre>

<pre><code>## [1] &quot;AUGCUUAUCUA&quot;
</code></pre>

<p>If you got a different result, go back and try to fix your function.</p>

<h2>Refine your translate function</h2>

<p>We&#39;re also going to make use of the <code>translate</code> function you wrote earlier in the week, but we&#39;ll need to update its interface a bit as well.</p>

<p>Add a <code>translate</code> function to <code>genomeAnnotation.r</code> that follows the following template:</p>

<pre><code class="r"># Translates RNA sequence into amino acid sequence
# 
# rna A character string containing RNA sequence
# 
# value A character string containing amino sequence
translate &lt;- function(rna) {

    # Insert your code here

}
</code></pre>

<p>There are two aspects to this new version of the <code>translate</code> function which are probably different than the version your wrote before.</p>

<p>First, as was the case with the <code>transcribe</code> function, we&#39;ve written this function so it expects to recieve a string of RNA sequence, rather than the name of a file to load.</p>

<p>Second, we&#39;ve explicitly stated that our function should return a <strong>single</strong> character string containing the amino acid sequence.  This is probably different than the value produced by your current version of <code>translate</code>.  Consider the difference between:</p>

<pre><code class="r"># Here are two example character vectors

# A vector of many elements; each element is only one character
c(&quot;V&quot;, &quot;R&quot;, &quot;S&quot;, &quot;P&quot;, &quot;L&quot;)
</code></pre>

<pre><code>## [1] &quot;V&quot; &quot;R&quot; &quot;S&quot; &quot;P&quot; &quot;L&quot;
</code></pre>

<pre><code class="r">
# A vector of one element; the element has many characters
&quot;VRSPL&quot;
</code></pre>

<pre><code>## [1] &quot;VRSPL&quot;
</code></pre>

<p>What we want our translate function to produce is like the 2nd example, what it produces is like the first.  So how can you take a character vector of many elements and turn it into a single-element vector of many characters?</p>

<p>The answer is the <code>paste</code> function:</p>

<pre><code class="r"># Some example uses of the paste function

paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), sep = &quot;&quot;)
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;
</code></pre>

<pre><code class="r">
paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), sep = &quot;, &quot;)
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;
</code></pre>

<p>Refactor your earlier version of the <code>translate</code> function so that it conforms to the interface in the template above.</p>

<p>Now test your translate function with some different inputs:</p>

<pre><code class="r">translate(&quot;AUG&quot;)
</code></pre>

<pre><code>## [1] &quot;M&quot;
</code></pre>

<pre><code class="r">translate(&quot;UUCUAAAUUAACAAAAUC&quot;)
</code></pre>

<pre><code>## [1] &quot;F&quot; &quot;X&quot; &quot;I&quot; &quot;N&quot; &quot;K&quot; &quot;I&quot;
</code></pre>

<pre><code class="r">translate(&quot;UUCUAAAUUAACAAAAU&quot;)
</code></pre>

<pre><code>## [1] &quot;F&quot; &quot;X&quot; &quot;I&quot; &quot;N&quot; &quot;K&quot;
</code></pre>

<pre><code class="r">translate(&quot;UUCUAAAUUAACAAAA&quot;)
</code></pre>

<pre><code>## [1] &quot;F&quot; &quot;X&quot; &quot;I&quot; &quot;N&quot; &quot;K&quot;
</code></pre>

<p>Did those last two lines fail for your function or did it work?  If you got an error or an &ldquo;NA&rdquo; at the end of your result vector, let&#39;s make our <code>translate</code> function a little bit smarter, so we don&#39;t have to worry about it choking on input strings that aren&#39;t evenly divisible by 3.  The easiest thing to do is to just have it ignore incomplete final codons.  Use your knowledge of the <code>nchar</code> and <code>substr</code> functions along with the arithematic modulo operator <code>%%</code> to refine the <code>translate</code> function.</p>

<p>When your function is working on all of the inputs above, you&#39;re ready to move on to step 2!</p>

<h1>Step 2: Writing an ORF finder</h1>

<h2>Function template</h2>

<p>We now have the tools in place that we&#39;ll need to write a function that finds ORFs.  This function will take a string containing a sequence of amino acids and find <em>all</em> of the possible ORFs in that string.  The logic of this function will be to identify stretches of aminoacids that start with a methionine (&ldquo;M&rdquo;) and end with one of our stop codons (&ldquo;X&rdquo;).  This function will also accept a &#39;cutoff&#39; argument which will be used to filter ORFs that are too short to be believable.</p>

<p>Let&#39;s start off by adding a template for the <code>findORF</code> function to our <code>genomeAnnotation.r</code> script.</p>

<pre><code class="r"># Returns a data.frame describing the ORFs found in the given aminoacid
# sequence
# 
# aminoacids A character string containing aminoacid sequence cutoff An
# integer giving the minimum aminoacid length of valid ORFs
# 
# value A data.frame, coordinates refer to amino acid position
findORF &lt;- function(aminoacids, cutoff = 100) {

    # Insert your code here

}
</code></pre>

<p>In this function definition we&#39;ve done something new:  provide a default value for one of our arguments.  The expression <code>cutoff = 100</code> sets 100 as the default value of the cutoff argument.  If the user of the function supplies a cutoff it will override the default; if they don&#39;t the default will be used.  It is a good &ldquo;best-practice&rdquo; to provide reasonable default values for optional arguments.  Optional arguments are usually arguments which tweak the behavior of the function in some way, but don&#39;t represent data that are fundamental to its operation.</p>

<p>So what&#39;s the first thing this function is going to need to do?  We want it to find stretches of amino acids that look like they correspond to real open reading frames.  What&#39;s the best way to look for small patterns in larger strings?  The answer is regular expressions.</p>

<h2>Regular expressions</h2>

<p>Regular expressions are a powerful tool available in many programming languages which are designed to find patterns in text.  Regular expressions are a mini-programming language all of their own which allows us to describe many different types of complex patterns.</p>

<p>In this case the pattern we need to find is:</p>

<p><code>M...X</code></p>

<p>Where &ldquo;M&rdquo; is a methionine, &ldquo;X&rdquo; is one of our stop codons, and &ldquo;&hellip;&rdquo; represents a variable number of amino acids between M and X.  Furthermore, we want to find ALL of the non-overlapping instances of the &ldquo;M&hellip;X&rdquo; pattern in our input aminoacid sequence.</p>

<p>You can read about the full power of the <a href="http://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html">regular expression syntax</a> in the R help, but for today I&#39;ll guide you through how to write them.</p>

<p>Our regular expression pattern is going to be the string:</p>

<p><code>&quot;M(.*?)X&quot;</code></p>

<p>Here&#39;s what&#39;s going on in the pattern:</p>

<ul>
<li>The &ldquo;M&rdquo; at the begining says &#39;look for patterns that start with M&#39;</li>
<li>The &ldquo;X&rdquo; at the end says &#39;&hellip;and end with X&#39;</li>
<li>The &ldquo;(&hellip;)&rdquo; adds a subpattern that we&#39;ll search for between the M and X</li>
<li>&ldquo;.&rdquo; says &#39;find any character that isn&#39;t a space&#39;</li>
<li>The &ldquo;*&rdquo; says &#39;find between 0 and an infinite number of those non-space characters&#39;</li>
<li>The &ldquo;?&rdquo; says &#39;but make the stuff inside of the &ldquo;(&hellip;)&rdquo; as small as possible, while still conforming to my other rules&#39;.  If we didn&#39;t add the &ldquo;?&rdquo; this pattern would match starting at the first M in our sequence &ndash; then gobble up all other M&#39;s and X&#39;s &ndash; until it hit the last X in the sequence.  Obviously, not what we want!</li>
</ul>

<p>All of the functions listed on the help page for <code>?sub</code> can take regular expressions as their search patterns.  Today we&#39;ll use <code>gregexpr</code> (global regular expression) function.</p>

<p>When trying to learn how a new function works, it&#39;s often useful to make up some example data that will make it easy to discover what a function is doing.  Let&#39;s make a sample &ldquo;amino acid&rdquo; sequence that will be easy to keep track of.</p>

<pre><code class="r">sampleAminoAcids &lt;- &quot;aaaaMbbbbXccccMddddXeeee&quot;
</code></pre>

<p>See what I did there?  If everything is working correctly we should find &ldquo;MbbbbX&rdquo; and &ldquo;MddddX&rdquo; and nothing else.</p>

<p>Let&#39;s give <code>gregexpr</code> a whirl with our sample data and our regular expression:</p>

<pre><code class="r">gregexpr(pattern = &quot;M(.*?)X&quot;, text = sampleAminoAcids)
</code></pre>

<pre><code>## [[1]]
## [1]  5 15
## attr(,&quot;match.length&quot;)
## [1] 6 6
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<p>There&#39;s a lot going with the output from this function &ndash; we&#39;re starting to get a peak at some advanced R features.  But notice that line that has the vector <code>5, 15</code>?  That suspiciously similar to the positions of our &ldquo;M&rdquo;&#39;s in the sample string.  See the line that has the vector <code>6, 6</code>?  Rather interesting, since both of our sample ORF sequences should be 6 amino acids long!  As a novice user, you should be thinking to yourself &ldquo;I think this is going to work for us&rdquo;!</p>

<p>The structure being returned by <code>gregexpr</code> is called a <code>list</code>.  It&#39;s kind of like a basket that can hold other smaller types of data, like vectors.  We&#39;re not going to get distracted with the details today; instead let&#39;s jump to how we can extract our ORF start poistions and lengths from this structure.</p>

<p>Try the following:</p>

<pre><code class="r">matches &lt;- gregexpr(pattern = &quot;M(.*?)X&quot;, text = sampleAminoAcids)
startPositions &lt;- as.vector(matches[[1]])
lengths &lt;- attr(matches[[1]], &quot;match.length&quot;)

# ORF match staring positions
startPositions
</code></pre>

<pre><code>## [1]  5 15
</code></pre>

<pre><code class="r">
# ORF match lengths
lengths
</code></pre>

<pre><code>## [1] 6 6
</code></pre>

<p>If you&#39;re interested in what the &ldquo;[[1]]&rdquo; is about:  had our text argument been a vector with more than one string matches would have had additional elements accisible with [[2]]&hellip;[[n]].  If this detail stresses you out; ignore it!</p>

<p>Let&#39;s also use our knowledge of <code>substring</code> to get the actual amino acid sequence:</p>

<pre><code class="r">orfSequence &lt;- substring(sampleAminoAcids, first = startPositions, last = startPositions + 
    lengths - 1)
</code></pre>

<p>What does orfSequence hold now?  Why do we need the &ldquo;-1&rdquo; in the last argument?  </p>

<p>So now we know how to write code that will match all of the possible ORFs in a sequence of amino acids!  Now let&#39;s think about how we want to collect our ORF information in a user friendly way.</p>

<h2>Creating a data.frame</h2>

<p>We&#39;ve used data.frame&#39;s before by loading tabular data in from files, but you can also create them <em>de novo</em> from with in an R session.  The syntax is:</p>

<pre><code class="r">data.frame(variable1 = c(1, 2, 3, 4), variable2 = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;))
</code></pre>

<pre><code>##   variable1 variable2
## 1         1         a
## 2         2         b
## 3         3         c
## 4         4         d
</code></pre>

<p>See what happened there?  Each argument will become a column heading in your data.frame, and its value will become the data in that column.  You&#39;ll want to make sure your value vectors are all the same lengths or you&#39;ll get an error.</p>

<p>So how can we store our ORF information in a convenient tabular format?  With something like this:</p>

<pre><code class="r">orfTable &lt;- data.frame(startPosition = startPositions, length = lengths, aminoacids = orfSequence)
</code></pre>

<p>Take a look at the contents of orfTable.  We&#39;re nearly there!  It&#39;s time to take all of the parts we&#39;ve just looked at and assemble them back into a whole.  </p>

<p>Return to the template for your <code>findOrf</code> function above and fill in the function body.  The thing we promised that this function would do that we haven&#39;t handled yet is filtering out ORFs that are below the size given by the <code>cutoff</code> argument.  Use your knowledge of selectors (<code>[]</code>) to filter the final version version of your orfTable based on the values in the <code>length</code> column.</p>

<p>Finally, we&#39;ve promised that our function returns a data.frame.  Up to this point we haven&#39;t explicitly addressed how we tell R what to return as the value of our functions.  If we don&#39;t tell R what to do, it will just return the result of the last computation by default.  We can be explicit about what we want to return from our function using the <code>return</code> function, like: <code>return(orfTable)</code></p>

<h1>Step 3:  Chromosome annotation</h1>

<h2>Overview</h2>

<p>Now we&#39;re ready to think about the structure of our function which will annotate all of the possible ORFs in the sequence for a chromosome.  Here&#39;s the template we&#39;ll use for our big annotation function:</p>

<pre><code class="r"># Finds all open reading frames in the chromosome sequence in a FASTA file
# 
# fastaFile A string containing the name of a chromosome file in FASTA
# format
# 
# value A data.frame.  Coordinates are relative to DNA sequence in input.
annotateChromosome &lt;- function(fastaFile) {

    # Insert your code here

}
</code></pre>

<p>We&#39;ll also write a few helper functions to keep annotateChromosome from becomming too bloated.</p>

<p>Here are the templates:</p>

<pre><code class="r"># Parses a sequence file in FASTA format
# 
# fastaFile A string giving the name of a fasta file to parse
# 
# value A string containing the parsed sequence
loadFASTA &lt;- function(fastaFile) {

    # Insert your code here

}

# Annotates the ORFs found in a given frame of a dnaString
# 
# dnaStrand A string containing DNA sequence offset The frame offset (0,
# 1, or 2)
# 
# value A data.frame.  Coordinates are relative to dnaStrand.
annotateFrame &lt;- function(dnaStrand, offset) {

    # Insert your code here

}

# Calculates the reverse complement of a dnaStrand
# 
# dnaStrand A string containing the forward DNA sequence
# 
# value A string containing the reverse complement to dnaStrand
reverseComplement &lt;- function(dnaStrand) {

    # Insert your code here

}

# Reverses the characters in a string
reverseString &lt;- function(a) {
    paste(rev(substring(a, 1:nchar(a), 1:nchar(a))), collapse = &quot;&quot;)
}
</code></pre>

<p>I snuck in a function implementation in the last section; this is a common idiom used in R to reverse the sequence of a string.  Hopefully you can prove to yourself that you understand why it works!</p>

<p>I&#39;m not going to walk you through exactly how to write the body of each of these functions.  Instead, I&#39;ll give some pointers for each in the sections that follow.</p>

<h2>reverseComplement</h2>

<p>To implement this function you&#39;ll probably want to use the <code>reverseString</code> utility function.  You&#39;ll hopefully also be thinking that you&#39;ll want to use <code>gsub</code> to switch A -&gt; T, G -&gt; C and visa versa.</p>

<p>However, consider the following:</p>

<pre><code class="r">dna &lt;- &quot;ATGCATCG&quot;
dna &lt;- gsub(&quot;A&quot;, &quot;T&quot;, dna)
dna
</code></pre>

<pre><code>## [1] &quot;TTGCTTCG&quot;
</code></pre>

<pre><code class="r">dna &lt;- gsub(&quot;G&quot;, &quot;C&quot;, dna)
dna
</code></pre>

<pre><code>## [1] &quot;TTCCTTCC&quot;
</code></pre>

<pre><code class="r">dna &lt;- gsub(&quot;T&quot;, &quot;A&quot;, dna)
dna
</code></pre>

<pre><code>## [1] &quot;AACCAACC&quot;
</code></pre>

<pre><code class="r">dna &lt;- gsub(&quot;C&quot;, &quot;G&quot;, dna)
dna
</code></pre>

<pre><code>## [1] &quot;AAGGAAGG&quot;
</code></pre>

<p>What happened here?  To get around this problem you can use a little trick: switch the case of the substitution letter then use the <code>toupper</code> function to convert lower case letters back to upper case.  For example:</p>

<pre><code class="r">dna &lt;- &quot;ATGCATCG&quot;
dna &lt;- gsub(&quot;A&quot;, &quot;t&quot;, dna)
dna
</code></pre>

<pre><code>## [1] &quot;tTGCtTCG&quot;
</code></pre>

<pre><code class="r">dna &lt;- toupper(dna)
dna
</code></pre>

<pre><code>## [1] &quot;TTGCTTCG&quot;
</code></pre>

<h2>annotateFrame</h2>

<p>This function is setup to accept a frame <code>offset</code> argument.  You&#39;ll call <code>annotateFrame</code> from annotate chromosome six times, once for each strand, and three times with offset = 0, offset = 1, and offset = 2.</p>

<p>If you call findORFs from annotateFrame remember that you&#39;ll want to convert lenths and startPositions from the amino acid coordinates to the correct DNA coordinates.  To update the data from a data.frame in place you can use the following syntax:</p>

<pre><code class="r">orfTable$length &lt;- orfTable$length * 2
</code></pre>

<h2>loadFASTA</h2>

<p>You can download yeast genome sequence <a href="http://downloads.yeastgenome.org/sequence/S288C_reference/chromosomes/fasta/">here</a>.  Each of these files contains the DNA sequence for one of the yeast chromosomes.</p>

<p>Take a look at the format of FASTA files.  You&#39;ll want to omit the first line of this file because it doesn&#39;t contain sequence.  We can do that with selectors:</p>

<pre><code class="r">dnaLines &lt;- readLines(&quot;sample.fasta&quot;)
</code></pre>

<pre><code>## Warning: cannot open file &#39;sample.fasta&#39;: No such file or directory
</code></pre>

<pre><code>## Error: cannot open the connection
</code></pre>

<pre><code class="r">dnaLines &lt;- dnaLines[2:length(dnaLines)]
</code></pre>

<pre><code>## Error: object &#39;dnaLines&#39; not found
</code></pre>

<p>Also we&#39;ll want to collapse all of the strings in this vector into a single string.  We can use paste to do that:</p>

<pre><code class="r">dna &lt;- paste(dnaLines, collapse = &quot;&quot;, sep = &quot;&quot;)
</code></pre>

<pre><code>## Error: object &#39;dnaLines&#39; not found
</code></pre>

<h2>Combining data.frame objects</h2>

<p>In several places you&#39;ll want to be able to combine <code>data.frame</code> tables, adding the rows of one table to another.  See the <code>merge</code> function of a convenient way to do this!</p>

<h1>Step 4: Annotate the whole genome!</h1>

<p>Once you have your annotateChromosome function working (takes the name of a chromosome FASTA file and produces a data.frame with ORF information), we&#39;re ready to write our final annotateGenome function.  This function should run annotateChromosome on each of the yeast chromosome FASTA files (in your directory), and aggregate all of the results in to a big table!</p>

<p>You can save this final data.frame using the &ldquo;write.table&rdquo; function like:</p>

<pre><code class="r">sampleTable = data.frame()
write.table(sampleTable, &quot;myFile.txt&quot;, sep = &quot;\t&quot;)
</code></pre>

<h1>Challenge #1:  Transcription factor binding site</h1>

<p>The TATA-Binding Protein (<a href="http://en.wikipedia.org/wiki/TATA-binding_protein">TBP</a>) is an important eukaryotic transcription factor.  It promotes transcription at many, but not all, eukaryotic genes.  It binds to the &ldquo;TATA-box&rdquo; sequence upstream of genes:</p>

<p>TATAAA</p>

<p>Modify your annotation script so that it produces a table listing TBP binding sites in the yeast genome.  Include a column that lists the likely ORF that is the target of TBP transcription target.  Remember that you&#39;ll have to keep track of both DNA strands.</p>

<p>What percentage of yeast genes are likely transcribed by TBP bound promoters?</p>

<h1>Challenge #2:  Handle introns</h1>

<p>Yeast is a eukaryote, which means the protein coding sequences (ORFs) can be interupted by introns.  Introns are defined by 3 sequences: start sequence, end sequence and a special sequence in the middle of the intron called a branch point sequence.  Unlike the TATA-Box however, each of these sequences comes in several different flavors.  Specifically, the variants are:</p>

<p>Start sites: 
GUAUGU 
GUAAGU 
GUAUGC 
GUAUGA 
GUACGU 
GUCAGU 
GUUAAG 
GUAGUA 
GCAUGU 
GUUCGU 
GUGAGU 
GCAAGU</p>

<p>Branch points:
GACUAAC 
UACUAAC 
AACUAAC 
AAUUAAC 
CACUAAC 
UGCUAAC 
UAUUAAC 
AGUUAAC 
CGUUAAC 
UGUUAAC 
CAUUAAC</p>

<p>End sites:
CAG
AAG
UAG</p>

<p>We can use regular expressions to find patterns that have variable characters at different positions.  Consider the following example:</p>

<pre><code class="r">grepl(&quot;bio285&quot;, &quot;Hello bio285!&quot;)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">grepl(&quot;bio285&quot;, &quot;Hello bio385!&quot;)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">
# Match course number 285 or 385
grepl(&quot;bio[23]85&quot;, &quot;Hello bio285!&quot;)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">grepl(&quot;bio[23]85&quot;, &quot;Hello bio285!&quot;)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>See what happened there?  The &ldquo;[ &hellip; ]&rdquo; say &#39;match any of the letters or numbers listed inside these brackets at this position.  So to match all splice end sites we could use the regular expression:</p>

<p><code>&quot;[CAU]AG&quot;</code></p>

<p>Refactor your annotateChromosome function so that it first finds and then removes (hint: gsub) all of the likely introns from the chromosomal sequence before attempting to annotate the ORFs.</p>

<p>How did your ORF list change when you accounted for introns?</p>

</body>

</html>

